/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter ts_nocheck,eslint_disable,add_pb_suffix
// @generated from protobuf file "pob2.proto" (package "pob2", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// pob2.proto
// Path of Building 2 - Web Edition
// Proto definitions for network/storage types
// Source of truth for all data structures
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp_pb";
// ============================================================================
// CHARACTER & BUILD
// ============================================================================

/**
 * @generated from protobuf message pob2.Build
 */
export interface Build {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - unique build identifier
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional pob2.CharacterClass character_class = 3
     */
    characterClass?: CharacterClass;
    /**
     * @generated from protobuf field: optional string ascendancy = 4
     */
    ascendancy?: string;
    /**
     * @generated from protobuf field: optional int32 level = 5
     */
    level?: number;
    /**
     * Passive tree
     *
     * @generated from protobuf field: repeated string allocated_node_ids = 10
     */
    allocatedNodeIds: string[];
    /**
     * @generated from protobuf field: map<string, string> mastery_selections = 11
     */
    masterySelections: {
        [key: string]: string;
    }; // node_id -> effect_id
    /**
     * Equipped items by slot
     *
     * @generated from protobuf field: map<string, pob2.Item> equipped_items = 20
     */
    equippedItems: {
        [key: string]: Item;
    };
    /**
     * Skill configuration
     *
     * @generated from protobuf field: repeated pob2.SkillGroup skill_groups = 30
     */
    skillGroups: SkillGroup[];
    /**
     * Build configuration options
     *
     * @generated from protobuf field: optional pob2.BuildConfig config = 40
     */
    config?: BuildConfig;
    /**
     * Metadata
     *
     * @generated from protobuf field: optional string notes = 50
     */
    notes?: string;
    /**
     * @generated from protobuf field: optional string build_code = 51
     */
    buildCode?: string; // Base64 encoded for sharing
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp created_at = 52
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp updated_at = 53
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message pob2.BuildConfig
 */
export interface BuildConfig {
    /**
     * Enemy configuration
     *
     * @generated from protobuf field: optional int32 enemy_level = 1
     */
    enemyLevel?: number;
    /**
     * @generated from protobuf field: optional bool enemy_is_boss = 2
     */
    enemyIsBoss?: boolean;
    /**
     * @generated from protobuf field: optional string enemy_type = 3
     */
    enemyType?: string;
    /**
     * Buff configuration
     *
     * @generated from protobuf field: optional bool power_charges = 10
     */
    powerCharges?: boolean;
    /**
     * @generated from protobuf field: optional bool frenzy_charges = 11
     */
    frenzyCharges?: boolean;
    /**
     * @generated from protobuf field: optional bool endurance_charges = 12
     */
    enduranceCharges?: boolean;
    /**
     * @generated from protobuf field: optional int32 power_charge_count = 13
     */
    powerChargeCount?: number;
    /**
     * @generated from protobuf field: optional int32 frenzy_charge_count = 14
     */
    frenzyChargeCount?: number;
    /**
     * @generated from protobuf field: optional int32 endurance_charge_count = 15
     */
    enduranceChargeCount?: number;
    /**
     * Combat state
     *
     * @generated from protobuf field: optional bool is_leeching = 20
     */
    isLeeching?: boolean;
    /**
     * @generated from protobuf field: optional bool is_on_low_life = 21
     */
    isOnLowLife?: boolean;
    /**
     * @generated from protobuf field: optional bool is_on_full_life = 22
     */
    isOnFullLife?: boolean;
    /**
     * @generated from protobuf field: optional bool enemy_is_chilled = 23
     */
    enemyIsChilled?: boolean;
    /**
     * @generated from protobuf field: optional bool enemy_is_frozen = 24
     */
    enemyIsFrozen?: boolean;
    /**
     * @generated from protobuf field: optional bool enemy_is_shocked = 25
     */
    enemyIsShocked?: boolean;
    /**
     * @generated from protobuf field: optional bool enemy_is_ignited = 26
     */
    enemyIsIgnited?: boolean;
}
// ============================================================================
// PASSIVE TREE
// ============================================================================

/**
 * @generated from protobuf message pob2.PassiveNode
 */
export interface PassiveNode {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - node hash from GGG tree data
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional pob2.NodeType node_type = 3
     */
    nodeType?: NodeType;
    /**
     * @generated from protobuf field: repeated string stats = 4
     */
    stats: string[]; // Stat descriptions
    /**
     * @generated from protobuf field: repeated string linked_ids = 5
     */
    linkedIds: string[]; // Connected node IDs
    /**
     * Position
     *
     * @generated from protobuf field: optional pob2.Position position = 6
     */
    position?: Position;
    /**
     * @generated from protobuf field: optional int32 group = 7
     */
    group?: number;
    /**
     * @generated from protobuf field: optional int32 orbit = 8
     */
    orbit?: number;
    /**
     * @generated from protobuf field: optional int32 orbit_index = 9
     */
    orbitIndex?: number;
    /**
     * Ascendancy
     *
     * @generated from protobuf field: optional string ascendancy_name = 10
     */
    ascendancyName?: string;
    /**
     * @generated from protobuf field: optional bool is_ascendancy_start = 11
     */
    isAscendancyStart?: boolean;
    /**
     * Visual
     *
     * @generated from protobuf field: optional string icon = 12
     */
    icon?: string;
    /**
     * @generated from protobuf field: optional bool is_proxy = 13
     */
    isProxy?: boolean;
    /**
     * Class start
     *
     * @generated from protobuf field: optional pob2.CharacterClass class_start_index = 14
     */
    classStartIndex?: CharacterClass;
}
/**
 * @generated from protobuf message pob2.PassiveTree
 */
export interface PassiveTree {
    /**
     * @generated from protobuf field: string version = 1
     */
    version: string; // Tree version/patch
    /**
     * @generated from protobuf field: repeated pob2.PassiveNode nodes = 2
     */
    nodes: PassiveNode[];
    /**
     * @generated from protobuf field: repeated pob2.NodeGroup groups = 3
     */
    groups: NodeGroup[];
    /**
     * Class start positions
     *
     * @generated from protobuf field: map<int32, string> class_start_nodes = 10
     */
    classStartNodes: {
        [key: number]: string;
    }; // class_id -> node_id
    /**
     * Constants
     *
     * @generated from protobuf field: optional pob2.TreeConstants constants = 20
     */
    constants?: TreeConstants;
}
/**
 * @generated from protobuf message pob2.NodeGroup
 */
export interface NodeGroup {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: optional pob2.Position position = 2
     */
    position?: Position;
    /**
     * @generated from protobuf field: repeated string node_ids = 3
     */
    nodeIds: string[];
    /**
     * @generated from protobuf field: optional bool is_proxy = 4
     */
    isProxy?: boolean;
}
/**
 * @generated from protobuf message pob2.TreeConstants
 */
export interface TreeConstants {
    /**
     * @generated from protobuf field: repeated int32 orbit_radii = 1
     */
    orbitRadii: number[];
    /**
     * @generated from protobuf field: repeated int32 skills_per_orbit = 2
     */
    skillsPerOrbit: number[];
}
/**
 * @generated from protobuf message pob2.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: float x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2
     */
    y: number;
}
// ============================================================================
// ITEMS
// ============================================================================

/**
 * @generated from protobuf message pob2.Item
 */
export interface Item {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - unique item identifier
    /**
     * Identity
     *
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string base_name = 3
     */
    baseName?: string;
    /**
     * @generated from protobuf field: optional string type_line = 4
     */
    typeLine?: string;
    /**
     * @generated from protobuf field: optional pob2.ItemRarity rarity = 5
     */
    rarity?: ItemRarity;
    /**
     * @generated from protobuf field: optional pob2.ItemType item_type = 6
     */
    itemType?: ItemType;
    /**
     * Properties
     *
     * @generated from protobuf field: optional int32 item_level = 10
     */
    itemLevel?: number;
    /**
     * @generated from protobuf field: optional int32 quality = 11
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional bool corrupted = 12
     */
    corrupted?: boolean;
    /**
     * @generated from protobuf field: optional bool mirrored = 13
     */
    mirrored?: boolean;
    /**
     * @generated from protobuf field: optional bool fractured = 14
     */
    fractured?: boolean;
    /**
     * Requirements
     *
     * @generated from protobuf field: optional int32 required_level = 20
     */
    requiredLevel?: number;
    /**
     * @generated from protobuf field: optional int32 required_str = 21
     */
    requiredStr?: number;
    /**
     * @generated from protobuf field: optional int32 required_dex = 22
     */
    requiredDex?: number;
    /**
     * @generated from protobuf field: optional int32 required_int = 23
     */
    requiredInt?: number;
    /**
     * Sockets & Runes (PoE2)
     *
     * @generated from protobuf field: repeated pob2.Socket sockets = 30
     */
    sockets: Socket[];
    /**
     * @generated from protobuf field: repeated string runes = 31
     */
    runes: string[];
    /**
     * Modifiers
     *
     * @generated from protobuf field: repeated string implicit_mods = 40
     */
    implicitMods: string[];
    /**
     * @generated from protobuf field: repeated string explicit_mods = 41
     */
    explicitMods: string[];
    /**
     * @generated from protobuf field: repeated string enchant_mods = 42
     */
    enchantMods: string[];
    /**
     * @generated from protobuf field: repeated string rune_mods = 43
     */
    runeMods: string[];
    /**
     * @generated from protobuf field: repeated string crafted_mods = 44
     */
    craftedMods: string[];
    /**
     * Weapon data (if applicable)
     *
     * @generated from protobuf field: optional pob2.WeaponData weapon_data = 50
     */
    weaponData?: WeaponData;
    /**
     * Armour data (if applicable)
     *
     * @generated from protobuf field: optional pob2.ArmourData armour_data = 51
     */
    armourData?: ArmourData;
    /**
     * Flask data (if applicable)
     *
     * @generated from protobuf field: optional pob2.FlaskData flask_data = 52
     */
    flaskData?: FlaskData;
    /**
     * Jewel data (if applicable)
     *
     * @generated from protobuf field: optional pob2.JewelData jewel_data = 53
     */
    jewelData?: JewelData;
}
/**
 * @generated from protobuf message pob2.Socket
 */
export interface Socket {
    /**
     * @generated from protobuf field: optional string color = 1
     */
    color?: string; // R, G, B, W, A (abyss)
    /**
     * @generated from protobuf field: optional int32 group = 2
     */
    group?: number; // Link group
}
/**
 * @generated from protobuf message pob2.WeaponData
 */
export interface WeaponData {
    /**
     * @generated from protobuf field: optional int32 physical_min = 1
     */
    physicalMin?: number;
    /**
     * @generated from protobuf field: optional int32 physical_max = 2
     */
    physicalMax?: number;
    /**
     * @generated from protobuf field: optional int32 fire_min = 3
     */
    fireMin?: number;
    /**
     * @generated from protobuf field: optional int32 fire_max = 4
     */
    fireMax?: number;
    /**
     * @generated from protobuf field: optional int32 cold_min = 5
     */
    coldMin?: number;
    /**
     * @generated from protobuf field: optional int32 cold_max = 6
     */
    coldMax?: number;
    /**
     * @generated from protobuf field: optional int32 lightning_min = 7
     */
    lightningMin?: number;
    /**
     * @generated from protobuf field: optional int32 lightning_max = 8
     */
    lightningMax?: number;
    /**
     * @generated from protobuf field: optional int32 chaos_min = 9
     */
    chaosMin?: number;
    /**
     * @generated from protobuf field: optional int32 chaos_max = 10
     */
    chaosMax?: number;
    /**
     * @generated from protobuf field: optional float attack_speed = 11
     */
    attackSpeed?: number;
    /**
     * @generated from protobuf field: optional float crit_chance = 12
     */
    critChance?: number; // Percentage * 100 (e.g., 650 = 6.50%)
    /**
     * @generated from protobuf field: optional int32 range = 13
     */
    range?: number;
}
/**
 * @generated from protobuf message pob2.ArmourData
 */
export interface ArmourData {
    /**
     * @generated from protobuf field: optional int32 armour = 1
     */
    armour?: number;
    /**
     * @generated from protobuf field: optional int32 evasion = 2
     */
    evasion?: number;
    /**
     * @generated from protobuf field: optional int32 energy_shield = 3
     */
    energyShield?: number;
    /**
     * @generated from protobuf field: optional int32 ward = 4
     */
    ward?: number;
    /**
     * @generated from protobuf field: optional int32 block = 5
     */
    block?: number; // Percentage * 100
}
/**
 * @generated from protobuf message pob2.FlaskData
 */
export interface FlaskData {
    /**
     * @generated from protobuf field: optional int32 life_recovery = 1
     */
    lifeRecovery?: number;
    /**
     * @generated from protobuf field: optional int32 mana_recovery = 2
     */
    manaRecovery?: number;
    /**
     * @generated from protobuf field: optional int32 duration = 3
     */
    duration?: number; // Milliseconds
    /**
     * @generated from protobuf field: optional int32 charges_used = 4
     */
    chargesUsed?: number;
    /**
     * @generated from protobuf field: optional int32 charges_max = 5
     */
    chargesMax?: number;
}
/**
 * @generated from protobuf message pob2.JewelData
 */
export interface JewelData {
    /**
     * @generated from protobuf field: optional int32 radius = 1
     */
    radius?: number;
    /**
     * @generated from protobuf field: optional string limit = 2
     */
    limit?: string; // Limit text
    /**
     * @generated from protobuf field: optional bool is_cluster = 3
     */
    isCluster?: boolean;
    /**
     * @generated from protobuf field: optional int32 cluster_size = 4
     */
    clusterSize?: number; // Small, Medium, Large
}
// ============================================================================
// SKILLS & GEMS
// ============================================================================

/**
 * @generated from protobuf message pob2.SkillGroup
 */
export interface SkillGroup {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED
    /**
     * @generated from protobuf field: optional string label = 2
     */
    label?: string;
    /**
     * @generated from protobuf field: optional bool enabled = 3
     */
    enabled?: boolean;
    /**
     * @generated from protobuf field: optional bool include_in_full_dps = 4
     */
    includeInFullDps?: boolean;
    /**
     * @generated from protobuf field: optional string slot = 5
     */
    slot?: string; // Item slot this skill group is in
    /**
     * @generated from protobuf field: repeated pob2.GemInstance gems = 10
     */
    gems: GemInstance[];
}
/**
 * @generated from protobuf message pob2.GemInstance
 */
export interface GemInstance {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - references gem data
    /**
     * @generated from protobuf field: optional string gem_id = 2
     */
    gemId?: string; // Base gem ID from game data
    /**
     * @generated from protobuf field: optional int32 level = 3
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 quality = 4
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional bool enabled = 5
     */
    enabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 count = 6
     */
    count?: number; // For support gems that can stack
    /**
     * Quality type (PoE2 has different quality types)
     *
     * @generated from protobuf field: optional pob2.GemQualityType quality_type = 10
     */
    qualityType?: GemQualityType;
}
/**
 * @generated from protobuf message pob2.Gem
 */
export interface Gem {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - base gem identifier
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional pob2.GemType gem_type = 3
     */
    gemType?: GemType;
    /**
     * @generated from protobuf field: optional string description = 4
     */
    description?: string;
    /**
     * Requirements per level
     *
     * @generated from protobuf field: repeated pob2.GemLevel levels = 10
     */
    levels: GemLevel[];
    /**
     * Tags
     *
     * @generated from protobuf field: repeated string tags = 20
     */
    tags: string[];
    /**
     * Base stats
     *
     * @generated from protobuf field: optional int32 base_mana_cost = 30
     */
    baseManaCost?: number;
    /**
     * @generated from protobuf field: optional int32 base_cast_time = 31
     */
    baseCastTime?: number; // Milliseconds
    /**
     * @generated from protobuf field: optional int32 base_cooldown = 32
     */
    baseCooldown?: number; // Milliseconds
}
/**
 * @generated from protobuf message pob2.GemLevel
 */
export interface GemLevel {
    /**
     * @generated from protobuf field: int32 level = 1
     */
    level: number;
    /**
     * @generated from protobuf field: optional int32 required_level = 2
     */
    requiredLevel?: number;
    /**
     * @generated from protobuf field: optional int32 mana_cost = 3
     */
    manaCost?: number;
    /**
     * @generated from protobuf field: optional int32 damage_effectiveness = 4
     */
    damageEffectiveness?: number; // Percentage * 100
    /**
     * Additional stats per level stored as key-value
     *
     * @generated from protobuf field: map<string, int32> stats = 10
     */
    stats: {
        [key: string]: number;
    };
}
// ============================================================================
// PATH OF LEVELING
// ============================================================================

/**
 * @generated from protobuf message pob2.LevelingPath
 */
export interface LevelingPath {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // REQUIRED - unique identifier
    /**
     * @generated from protobuf field: optional string build_id = 2
     */
    buildId?: string; // Reference to end-game Build (optional)
    /**
     * @generated from protobuf field: optional string name = 3
     */
    name?: string;
    /**
     * @generated from protobuf field: optional pob2.CharacterClass class_id = 4
     */
    classId?: CharacterClass;
    /**
     * @generated from protobuf field: repeated pob2.Checkpoint checkpoints = 5
     */
    checkpoints: Checkpoint[]; // User-defined level milestones
    /**
     * @generated from protobuf field: repeated pob2.LevelingStep steps = 6
     */
    steps: LevelingStep[]; // Ordered actions
    /**
     * @generated from protobuf field: optional string notes = 7
     */
    notes?: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp created_at = 8
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp updated_at = 9
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message pob2.Checkpoint
 */
export interface Checkpoint {
    /**
     * @generated from protobuf field: int32 level = 1
     */
    level: number; // User-defined level milestone
    /**
     * @generated from protobuf field: repeated string allocated_passives = 2
     */
    allocatedPassives: string[]; // Cumulative list of node IDs
    /**
     * @generated from protobuf field: map<string, pob2.Item> equipment = 3
     */
    equipment: {
        [key: string]: Item;
    }; // Slot -> Item mapping
    /**
     * @generated from protobuf field: repeated pob2.SkillGroup gems = 4
     */
    gems: SkillGroup[]; // Gem setup at this checkpoint
    /**
     * @generated from protobuf field: optional pob2.StatSnapshot stats = 5
     */
    stats?: StatSnapshot; // Calculated stats at this level
    /**
     * @generated from protobuf field: optional string notes = 6
     */
    notes?: string; // Checkpoint-specific notes
}
/**
 * @generated from protobuf message pob2.LevelingStep
 */
export interface LevelingStep {
    /**
     * @generated from protobuf field: int32 order = 1
     */
    order: number; // Execution order
    /**
     * @generated from protobuf field: optional pob2.StepTrigger trigger = 2
     */
    trigger?: StepTrigger; // When to perform this step
    /**
     * @generated from protobuf field: optional pob2.StepAction action = 3
     */
    action?: StepAction; // What to do
    /**
     * @generated from protobuf field: optional pob2.StatDelta stat_delta = 4
     */
    statDelta?: StatDelta; // Impact on stats
    /**
     * @generated from protobuf field: optional string rationale = 5
     */
    rationale?: string; // Why this step matters
}
/**
 * @generated from protobuf message pob2.StepTrigger
 */
export interface StepTrigger {
    /**
     * @generated from protobuf field: pob2.StepTriggerType type = 1
     */
    type: StepTriggerType;
    /**
     * @generated from protobuf field: optional string value = 2
     */
    value?: string; // Level number, quest name, or item name
}
/**
 * @generated from protobuf message pob2.StepAction
 */
export interface StepAction {
    /**
     * @generated from protobuf field: pob2.StepActionType type = 1
     */
    type: StepActionType;
    /**
     * @generated from protobuf field: optional string target_id = 2
     */
    targetId?: string; // Node ID, item ID, or gem ID
    /**
     * @generated from protobuf field: optional string slot = 3
     */
    slot?: string; // Item slot or socket position
    /**
     * @generated from protobuf field: optional string details = 4
     */
    details?: string; // Additional context
}
/**
 * @generated from protobuf message pob2.StatDelta
 */
export interface StatDelta {
    /**
     * @generated from protobuf field: optional float dps_percent = 1
     */
    dpsPercent?: number; // +/- percentage change
    /**
     * @generated from protobuf field: optional float ehp_percent = 2
     */
    ehpPercent?: number; // +/- percentage change
    /**
     * @generated from protobuf field: optional float dps_absolute = 3
     */
    dpsAbsolute?: number; // +/- absolute value
    /**
     * @generated from protobuf field: optional float ehp_absolute = 4
     */
    ehpAbsolute?: number; // +/- absolute value
    /**
     * @generated from protobuf field: map<string, float> resistances = 5
     */
    resistances: {
        [key: string]: number;
    }; // Resistance changes
    /**
     * @generated from protobuf field: map<string, float> other_stats = 6
     */
    otherStats: {
        [key: string]: number;
    }; // Other stat changes
}
/**
 * @generated from protobuf message pob2.StatSnapshot
 */
export interface StatSnapshot {
    /**
     * @generated from protobuf field: optional float dps = 1
     */
    dps?: number; // Damage per second
    /**
     * @generated from protobuf field: optional float ehp = 2
     */
    ehp?: number; // Effective HP
    /**
     * @generated from protobuf field: optional float life = 3
     */
    life?: number; // Maximum life
    /**
     * @generated from protobuf field: optional float mana = 4
     */
    mana?: number; // Maximum mana
    /**
     * @generated from protobuf field: optional float energy_shield = 5
     */
    energyShield?: number; // Maximum energy shield
    /**
     * @generated from protobuf field: optional int32 fire_res = 6
     */
    fireRes?: number; // Fire resistance (percentage)
    /**
     * @generated from protobuf field: optional int32 cold_res = 7
     */
    coldRes?: number; // Cold resistance (percentage)
    /**
     * @generated from protobuf field: optional int32 lightning_res = 8
     */
    lightningRes?: number; // Lightning resistance (percentage)
    /**
     * @generated from protobuf field: optional int32 chaos_res = 9
     */
    chaosRes?: number; // Chaos resistance (percentage)
    /**
     * @generated from protobuf field: optional float attack_speed = 10
     */
    attackSpeed?: number; // Attacks per second
    /**
     * @generated from protobuf field: optional float cast_speed = 11
     */
    castSpeed?: number; // Casts per second
    /**
     * @generated from protobuf field: optional float crit_chance = 12
     */
    critChance?: number; // Critical strike chance (percentage)
    /**
     * @generated from protobuf field: optional float crit_multi = 13
     */
    critMulti?: number; // Critical strike multiplier (percentage)
    /**
     * @generated from protobuf field: map<string, float> other = 14
     */
    other: {
        [key: string]: number;
    }; // Additional stats
}
// ============================================================================
// ENUMS
// ============================================================================

/**
 * @generated from protobuf enum pob2.CharacterClass
 */
export enum CharacterClass {
    /**
     * @generated from protobuf enum value: CHARACTER_CLASS_UNKNOWN = 0;
     */
    CHARACTER_CLASS_UNKNOWN = 0,
    /**
     * PoE2 Classes (new)
     *
     * @generated from protobuf enum value: WARRIOR = 1;
     */
    WARRIOR = 1,
    /**
     * @generated from protobuf enum value: MONK = 2;
     */
    MONK = 2,
    /**
     * @generated from protobuf enum value: SORCERESS = 3;
     */
    SORCERESS = 3,
    /**
     * @generated from protobuf enum value: MERCENARY = 4;
     */
    MERCENARY = 4,
    /**
     * @generated from protobuf enum value: HUNTRESS = 5;
     */
    HUNTRESS = 5,
    /**
     * @generated from protobuf enum value: DRUID = 6;
     */
    DRUID = 6,
    /**
     * PoE1 Classes (for compatibility)
     *
     * @generated from protobuf enum value: MARAUDER = 10;
     */
    MARAUDER = 10,
    /**
     * @generated from protobuf enum value: RANGER = 11;
     */
    RANGER = 11,
    /**
     * @generated from protobuf enum value: WITCH = 12;
     */
    WITCH = 12,
    /**
     * @generated from protobuf enum value: DUELIST = 13;
     */
    DUELIST = 13,
    /**
     * @generated from protobuf enum value: TEMPLAR = 14;
     */
    TEMPLAR = 14,
    /**
     * @generated from protobuf enum value: SHADOW = 15;
     */
    SHADOW = 15,
    /**
     * @generated from protobuf enum value: SCION = 16;
     */
    SCION = 16
}
/**
 * @generated from protobuf enum pob2.NodeType
 */
export enum NodeType {
    /**
     * @generated from protobuf enum value: NODE_TYPE_UNKNOWN = 0;
     */
    NODE_TYPE_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NODE_NORMAL = 1;
     */
    NODE_NORMAL = 1,
    /**
     * @generated from protobuf enum value: NODE_NOTABLE = 2;
     */
    NODE_NOTABLE = 2,
    /**
     * @generated from protobuf enum value: NODE_KEYSTONE = 3;
     */
    NODE_KEYSTONE = 3,
    /**
     * @generated from protobuf enum value: NODE_MASTERY = 4;
     */
    NODE_MASTERY = 4,
    /**
     * @generated from protobuf enum value: NODE_SOCKET = 5;
     */
    NODE_SOCKET = 5,
    /**
     * @generated from protobuf enum value: NODE_CLASS_START = 6;
     */
    NODE_CLASS_START = 6,
    /**
     * @generated from protobuf enum value: NODE_ASCEND_CLASS_START = 7;
     */
    NODE_ASCEND_CLASS_START = 7
}
/**
 * @generated from protobuf enum pob2.ItemRarity
 */
export enum ItemRarity {
    /**
     * @generated from protobuf enum value: ITEM_RARITY_UNKNOWN = 0;
     */
    ITEM_RARITY_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: RARITY_NORMAL = 1;
     */
    RARITY_NORMAL = 1,
    /**
     * @generated from protobuf enum value: RARITY_MAGIC = 2;
     */
    RARITY_MAGIC = 2,
    /**
     * @generated from protobuf enum value: RARITY_RARE = 3;
     */
    RARITY_RARE = 3,
    /**
     * @generated from protobuf enum value: RARITY_UNIQUE = 4;
     */
    RARITY_UNIQUE = 4
}
/**
 * @generated from protobuf enum pob2.ItemType
 */
export enum ItemType {
    /**
     * @generated from protobuf enum value: ITEM_TYPE_UNKNOWN = 0;
     */
    ITEM_TYPE_UNKNOWN = 0,
    /**
     * Weapons
     *
     * @generated from protobuf enum value: ONE_HAND_SWORD = 1;
     */
    ONE_HAND_SWORD = 1,
    /**
     * @generated from protobuf enum value: TWO_HAND_SWORD = 2;
     */
    TWO_HAND_SWORD = 2,
    /**
     * @generated from protobuf enum value: ONE_HAND_AXE = 3;
     */
    ONE_HAND_AXE = 3,
    /**
     * @generated from protobuf enum value: TWO_HAND_AXE = 4;
     */
    TWO_HAND_AXE = 4,
    /**
     * @generated from protobuf enum value: ONE_HAND_MACE = 5;
     */
    ONE_HAND_MACE = 5,
    /**
     * @generated from protobuf enum value: TWO_HAND_MACE = 6;
     */
    TWO_HAND_MACE = 6,
    /**
     * @generated from protobuf enum value: BOW = 7;
     */
    BOW = 7,
    /**
     * @generated from protobuf enum value: CROSSBOW = 8;
     */
    CROSSBOW = 8,
    /**
     * @generated from protobuf enum value: STAFF = 9;
     */
    STAFF = 9,
    /**
     * @generated from protobuf enum value: WAND = 10;
     */
    WAND = 10,
    /**
     * @generated from protobuf enum value: DAGGER = 11;
     */
    DAGGER = 11,
    /**
     * @generated from protobuf enum value: CLAW = 12;
     */
    CLAW = 12,
    /**
     * @generated from protobuf enum value: SCEPTRE = 13;
     */
    SCEPTRE = 13,
    /**
     * PoE2
     *
     * @generated from protobuf enum value: QUARTERSTAFF = 14;
     */
    QUARTERSTAFF = 14,
    /**
     * PoE2
     *
     * @generated from protobuf enum value: SPEAR = 15;
     */
    SPEAR = 15,
    /**
     * PoE2
     *
     * @generated from protobuf enum value: FLAIL = 16;
     */
    FLAIL = 16,
    /**
     * Armour
     *
     * @generated from protobuf enum value: HELMET = 20;
     */
    HELMET = 20,
    /**
     * @generated from protobuf enum value: BODY_ARMOUR = 21;
     */
    BODY_ARMOUR = 21,
    /**
     * @generated from protobuf enum value: GLOVES = 22;
     */
    GLOVES = 22,
    /**
     * @generated from protobuf enum value: BOOTS = 23;
     */
    BOOTS = 23,
    /**
     * @generated from protobuf enum value: SHIELD = 24;
     */
    SHIELD = 24,
    /**
     * PoE2 off-hand
     *
     * @generated from protobuf enum value: FOCUS = 25;
     */
    FOCUS = 25,
    /**
     * Accessories
     *
     * @generated from protobuf enum value: AMULET = 30;
     */
    AMULET = 30,
    /**
     * @generated from protobuf enum value: RING = 31;
     */
    RING = 31,
    /**
     * @generated from protobuf enum value: BELT = 32;
     */
    BELT = 32,
    /**
     * Other
     *
     * @generated from protobuf enum value: FLASK = 40;
     */
    FLASK = 40,
    /**
     * @generated from protobuf enum value: JEWEL = 41;
     */
    JEWEL = 41,
    /**
     * PoE2
     *
     * @generated from protobuf enum value: CHARM = 42;
     */
    CHARM = 42,
    /**
     * @generated from protobuf enum value: QUIVER = 43;
     */
    QUIVER = 43
}
/**
 * @generated from protobuf enum pob2.GemType
 */
export enum GemType {
    /**
     * @generated from protobuf enum value: GEM_TYPE_UNKNOWN = 0;
     */
    GEM_TYPE_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SKILL = 1;
     */
    SKILL = 1,
    /**
     * @generated from protobuf enum value: SUPPORT = 2;
     */
    SUPPORT = 2,
    /**
     * PoE2 meta gems
     *
     * @generated from protobuf enum value: META = 3;
     */
    META = 3
}
/**
 * @generated from protobuf enum pob2.GemQualityType
 */
export enum GemQualityType {
    /**
     * @generated from protobuf enum value: GEM_QUALITY_TYPE_UNKNOWN = 0;
     */
    GEM_QUALITY_TYPE_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SUPERIOR = 1;
     */
    SUPERIOR = 1,
    /**
     * @generated from protobuf enum value: ANOMALOUS = 2;
     */
    ANOMALOUS = 2,
    /**
     * @generated from protobuf enum value: DIVERGENT = 3;
     */
    DIVERGENT = 3,
    /**
     * @generated from protobuf enum value: PHANTASMAL = 4;
     */
    PHANTASMAL = 4
}
// ============================================================================
// ITEM SLOTS
// ============================================================================

/**
 * @generated from protobuf enum pob2.ItemSlot
 */
export enum ItemSlot {
    /**
     * @generated from protobuf enum value: ITEM_SLOT_UNKNOWN = 0;
     */
    ITEM_SLOT_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SLOT_WEAPON_1 = 1;
     */
    SLOT_WEAPON_1 = 1,
    /**
     * Off-hand / Shield / Focus
     *
     * @generated from protobuf enum value: SLOT_WEAPON_2 = 2;
     */
    SLOT_WEAPON_2 = 2,
    /**
     * @generated from protobuf enum value: SLOT_WEAPON_1_SWAP = 3;
     */
    SLOT_WEAPON_1_SWAP = 3,
    /**
     * @generated from protobuf enum value: SLOT_WEAPON_2_SWAP = 4;
     */
    SLOT_WEAPON_2_SWAP = 4,
    /**
     * @generated from protobuf enum value: SLOT_HELMET = 10;
     */
    SLOT_HELMET = 10,
    /**
     * @generated from protobuf enum value: SLOT_BODY_ARMOUR = 11;
     */
    SLOT_BODY_ARMOUR = 11,
    /**
     * @generated from protobuf enum value: SLOT_GLOVES = 12;
     */
    SLOT_GLOVES = 12,
    /**
     * @generated from protobuf enum value: SLOT_BOOTS = 13;
     */
    SLOT_BOOTS = 13,
    /**
     * @generated from protobuf enum value: SLOT_AMULET = 20;
     */
    SLOT_AMULET = 20,
    /**
     * @generated from protobuf enum value: SLOT_RING_1 = 21;
     */
    SLOT_RING_1 = 21,
    /**
     * @generated from protobuf enum value: SLOT_RING_2 = 22;
     */
    SLOT_RING_2 = 22,
    /**
     * @generated from protobuf enum value: SLOT_BELT = 23;
     */
    SLOT_BELT = 23,
    /**
     * @generated from protobuf enum value: SLOT_FLASK_1 = 30;
     */
    SLOT_FLASK_1 = 30,
    /**
     * @generated from protobuf enum value: SLOT_FLASK_2 = 31;
     */
    SLOT_FLASK_2 = 31,
    /**
     * @generated from protobuf enum value: SLOT_FLASK_3 = 32;
     */
    SLOT_FLASK_3 = 32,
    /**
     * @generated from protobuf enum value: SLOT_FLASK_4 = 33;
     */
    SLOT_FLASK_4 = 33,
    /**
     * @generated from protobuf enum value: SLOT_FLASK_5 = 34;
     */
    SLOT_FLASK_5 = 34,
    /**
     * @generated from protobuf enum value: SLOT_JEWEL_1 = 40;
     */
    SLOT_JEWEL_1 = 40,
    /**
     * ... more jewel slots as needed
     *
     * @generated from protobuf enum value: SLOT_JEWEL_2 = 41;
     */
    SLOT_JEWEL_2 = 41
}
/**
 * @generated from protobuf enum pob2.StepTriggerType
 */
export enum StepTriggerType {
    /**
     * @generated from protobuf enum value: STEP_TRIGGER_TYPE_UNKNOWN = 0;
     */
    STEP_TRIGGER_TYPE_UNKNOWN = 0,
    /**
     * Reach a certain level
     *
     * @generated from protobuf enum value: TRIGGER_LEVEL = 1;
     */
    TRIGGER_LEVEL = 1,
    /**
     * Complete a quest
     *
     * @generated from protobuf enum value: TRIGGER_QUEST = 2;
     */
    TRIGGER_QUEST = 2,
    /**
     * Acquire an item
     *
     * @generated from protobuf enum value: TRIGGER_ITEM = 3;
     */
    TRIGGER_ITEM = 3,
    /**
     * Enter a zone
     *
     * @generated from protobuf enum value: TRIGGER_ZONE = 4;
     */
    TRIGGER_ZONE = 4,
    /**
     * Reach a waypoint
     *
     * @generated from protobuf enum value: TRIGGER_WAYPOINT = 5;
     */
    TRIGGER_WAYPOINT = 5
}
/**
 * @generated from protobuf enum pob2.StepActionType
 */
export enum StepActionType {
    /**
     * @generated from protobuf enum value: STEP_ACTION_TYPE_UNKNOWN = 0;
     */
    STEP_ACTION_TYPE_UNKNOWN = 0,
    /**
     * Allocate passive node
     *
     * @generated from protobuf enum value: ACTION_ALLOCATE = 1;
     */
    ACTION_ALLOCATE = 1,
    /**
     * Equip an item
     *
     * @generated from protobuf enum value: ACTION_EQUIP = 2;
     */
    ACTION_EQUIP = 2,
    /**
     * Socket a gem
     *
     * @generated from protobuf enum value: ACTION_SOCKET = 3;
     */
    ACTION_SOCKET = 3,
    /**
     * Respec passive nodes
     *
     * @generated from protobuf enum value: ACTION_RESPEC = 4;
     */
    ACTION_RESPEC = 4,
    /**
     * Buy from vendor
     *
     * @generated from protobuf enum value: ACTION_VENDOR = 5;
     */
    ACTION_VENDOR = 5,
    /**
     * Craft an item
     *
     * @generated from protobuf enum value: ACTION_CRAFT = 6;
     */
    ACTION_CRAFT = 6,
    /**
     * Start using a skill
     *
     * @generated from protobuf enum value: ACTION_USE_SKILL = 7;
     */
    ACTION_USE_SKILL = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class Build$Type extends MessageType<Build> {
    constructor() {
        super("pob2.Build", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "character_class", kind: "enum", opt: true, T: () => ["pob2.CharacterClass", CharacterClass] },
            { no: 4, name: "ascendancy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "allocated_node_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "mastery_selections", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 20, name: "equipped_items", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Item } },
            { no: 30, name: "skill_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SkillGroup },
            { no: 40, name: "config", kind: "message", T: () => BuildConfig },
            { no: 50, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 51, name: "build_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 52, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 53, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Build>): Build {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.allocatedNodeIds = [];
        message.masterySelections = {};
        message.equippedItems = {};
        message.skillGroups = [];
        if (value !== undefined)
            reflectionMergePartial<Build>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Build): Build {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional pob2.CharacterClass character_class */ 3:
                    message.characterClass = reader.int32();
                    break;
                case /* optional string ascendancy */ 4:
                    message.ascendancy = reader.string();
                    break;
                case /* optional int32 level */ 5:
                    message.level = reader.int32();
                    break;
                case /* repeated string allocated_node_ids */ 10:
                    message.allocatedNodeIds.push(reader.string());
                    break;
                case /* map<string, string> mastery_selections */ 11:
                    this.binaryReadMap11(message.masterySelections, reader, options);
                    break;
                case /* map<string, pob2.Item> equipped_items */ 20:
                    this.binaryReadMap20(message.equippedItems, reader, options);
                    break;
                case /* repeated pob2.SkillGroup skill_groups */ 30:
                    message.skillGroups.push(SkillGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional pob2.BuildConfig config */ 40:
                    message.config = BuildConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* optional string notes */ 50:
                    message.notes = reader.string();
                    break;
                case /* optional string build_code */ 51:
                    message.buildCode = reader.string();
                    break;
                case /* optional google.protobuf.Timestamp created_at */ 52:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* optional google.protobuf.Timestamp updated_at */ 53:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: Build["masterySelections"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Build["masterySelections"] | undefined, val: Build["masterySelections"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.Build.mastery_selections");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap20(map: Build["equippedItems"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Build["equippedItems"] | undefined, val: Build["equippedItems"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Item.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.Build.equipped_items");
            }
        }
        map[key ?? ""] = val ?? Item.create();
    }
    internalBinaryWrite(message: Build, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional pob2.CharacterClass character_class = 3; */
        if (message.characterClass !== undefined)
            writer.tag(3, WireType.Varint).int32(message.characterClass);
        /* optional string ascendancy = 4; */
        if (message.ascendancy !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.ascendancy);
        /* optional int32 level = 5; */
        if (message.level !== undefined)
            writer.tag(5, WireType.Varint).int32(message.level);
        /* repeated string allocated_node_ids = 10; */
        for (let i = 0; i < message.allocatedNodeIds.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.allocatedNodeIds[i]);
        /* map<string, string> mastery_selections = 11; */
        for (let k of globalThis.Object.keys(message.masterySelections))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.masterySelections[k]).join();
        /* map<string, pob2.Item> equipped_items = 20; */
        for (let k of globalThis.Object.keys(message.equippedItems)) {
            writer.tag(20, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Item.internalBinaryWrite(message.equippedItems[k], writer, options);
            writer.join().join();
        }
        /* repeated pob2.SkillGroup skill_groups = 30; */
        for (let i = 0; i < message.skillGroups.length; i++)
            SkillGroup.internalBinaryWrite(message.skillGroups[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.BuildConfig config = 40; */
        if (message.config)
            BuildConfig.internalBinaryWrite(message.config, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* optional string notes = 50; */
        if (message.notes !== undefined)
            writer.tag(50, WireType.LengthDelimited).string(message.notes);
        /* optional string build_code = 51; */
        if (message.buildCode !== undefined)
            writer.tag(51, WireType.LengthDelimited).string(message.buildCode);
        /* optional google.protobuf.Timestamp created_at = 52; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp updated_at = 53; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Build
 */
export const Build = new Build$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildConfig$Type extends MessageType<BuildConfig> {
    constructor() {
        super("pob2.BuildConfig", [
            { no: 1, name: "enemy_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enemy_is_boss", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "enemy_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "power_charges", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "frenzy_charges", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "endurance_charges", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "power_charge_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "frenzy_charge_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "endurance_charge_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "is_leeching", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "is_on_low_life", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "is_on_full_life", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "enemy_is_chilled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "enemy_is_frozen", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "enemy_is_shocked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "enemy_is_ignited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BuildConfig>): BuildConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BuildConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildConfig): BuildConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 enemy_level */ 1:
                    message.enemyLevel = reader.int32();
                    break;
                case /* optional bool enemy_is_boss */ 2:
                    message.enemyIsBoss = reader.bool();
                    break;
                case /* optional string enemy_type */ 3:
                    message.enemyType = reader.string();
                    break;
                case /* optional bool power_charges */ 10:
                    message.powerCharges = reader.bool();
                    break;
                case /* optional bool frenzy_charges */ 11:
                    message.frenzyCharges = reader.bool();
                    break;
                case /* optional bool endurance_charges */ 12:
                    message.enduranceCharges = reader.bool();
                    break;
                case /* optional int32 power_charge_count */ 13:
                    message.powerChargeCount = reader.int32();
                    break;
                case /* optional int32 frenzy_charge_count */ 14:
                    message.frenzyChargeCount = reader.int32();
                    break;
                case /* optional int32 endurance_charge_count */ 15:
                    message.enduranceChargeCount = reader.int32();
                    break;
                case /* optional bool is_leeching */ 20:
                    message.isLeeching = reader.bool();
                    break;
                case /* optional bool is_on_low_life */ 21:
                    message.isOnLowLife = reader.bool();
                    break;
                case /* optional bool is_on_full_life */ 22:
                    message.isOnFullLife = reader.bool();
                    break;
                case /* optional bool enemy_is_chilled */ 23:
                    message.enemyIsChilled = reader.bool();
                    break;
                case /* optional bool enemy_is_frozen */ 24:
                    message.enemyIsFrozen = reader.bool();
                    break;
                case /* optional bool enemy_is_shocked */ 25:
                    message.enemyIsShocked = reader.bool();
                    break;
                case /* optional bool enemy_is_ignited */ 26:
                    message.enemyIsIgnited = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 enemy_level = 1; */
        if (message.enemyLevel !== undefined)
            writer.tag(1, WireType.Varint).int32(message.enemyLevel);
        /* optional bool enemy_is_boss = 2; */
        if (message.enemyIsBoss !== undefined)
            writer.tag(2, WireType.Varint).bool(message.enemyIsBoss);
        /* optional string enemy_type = 3; */
        if (message.enemyType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.enemyType);
        /* optional bool power_charges = 10; */
        if (message.powerCharges !== undefined)
            writer.tag(10, WireType.Varint).bool(message.powerCharges);
        /* optional bool frenzy_charges = 11; */
        if (message.frenzyCharges !== undefined)
            writer.tag(11, WireType.Varint).bool(message.frenzyCharges);
        /* optional bool endurance_charges = 12; */
        if (message.enduranceCharges !== undefined)
            writer.tag(12, WireType.Varint).bool(message.enduranceCharges);
        /* optional int32 power_charge_count = 13; */
        if (message.powerChargeCount !== undefined)
            writer.tag(13, WireType.Varint).int32(message.powerChargeCount);
        /* optional int32 frenzy_charge_count = 14; */
        if (message.frenzyChargeCount !== undefined)
            writer.tag(14, WireType.Varint).int32(message.frenzyChargeCount);
        /* optional int32 endurance_charge_count = 15; */
        if (message.enduranceChargeCount !== undefined)
            writer.tag(15, WireType.Varint).int32(message.enduranceChargeCount);
        /* optional bool is_leeching = 20; */
        if (message.isLeeching !== undefined)
            writer.tag(20, WireType.Varint).bool(message.isLeeching);
        /* optional bool is_on_low_life = 21; */
        if (message.isOnLowLife !== undefined)
            writer.tag(21, WireType.Varint).bool(message.isOnLowLife);
        /* optional bool is_on_full_life = 22; */
        if (message.isOnFullLife !== undefined)
            writer.tag(22, WireType.Varint).bool(message.isOnFullLife);
        /* optional bool enemy_is_chilled = 23; */
        if (message.enemyIsChilled !== undefined)
            writer.tag(23, WireType.Varint).bool(message.enemyIsChilled);
        /* optional bool enemy_is_frozen = 24; */
        if (message.enemyIsFrozen !== undefined)
            writer.tag(24, WireType.Varint).bool(message.enemyIsFrozen);
        /* optional bool enemy_is_shocked = 25; */
        if (message.enemyIsShocked !== undefined)
            writer.tag(25, WireType.Varint).bool(message.enemyIsShocked);
        /* optional bool enemy_is_ignited = 26; */
        if (message.enemyIsIgnited !== undefined)
            writer.tag(26, WireType.Varint).bool(message.enemyIsIgnited);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.BuildConfig
 */
export const BuildConfig = new BuildConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PassiveNode$Type extends MessageType<PassiveNode> {
    constructor() {
        super("pob2.PassiveNode", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node_type", kind: "enum", opt: true, T: () => ["pob2.NodeType", NodeType] },
            { no: 4, name: "stats", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "linked_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "position", kind: "message", T: () => Position },
            { no: 7, name: "group", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "orbit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "orbit_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "ascendancy_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "is_ascendancy_start", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "is_proxy", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "class_start_index", kind: "enum", opt: true, T: () => ["pob2.CharacterClass", CharacterClass] }
        ]);
    }
    create(value?: PartialMessage<PassiveNode>): PassiveNode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.stats = [];
        message.linkedIds = [];
        if (value !== undefined)
            reflectionMergePartial<PassiveNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PassiveNode): PassiveNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional pob2.NodeType node_type */ 3:
                    message.nodeType = reader.int32();
                    break;
                case /* repeated string stats */ 4:
                    message.stats.push(reader.string());
                    break;
                case /* repeated string linked_ids */ 5:
                    message.linkedIds.push(reader.string());
                    break;
                case /* optional pob2.Position position */ 6:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional int32 group */ 7:
                    message.group = reader.int32();
                    break;
                case /* optional int32 orbit */ 8:
                    message.orbit = reader.int32();
                    break;
                case /* optional int32 orbit_index */ 9:
                    message.orbitIndex = reader.int32();
                    break;
                case /* optional string ascendancy_name */ 10:
                    message.ascendancyName = reader.string();
                    break;
                case /* optional bool is_ascendancy_start */ 11:
                    message.isAscendancyStart = reader.bool();
                    break;
                case /* optional string icon */ 12:
                    message.icon = reader.string();
                    break;
                case /* optional bool is_proxy */ 13:
                    message.isProxy = reader.bool();
                    break;
                case /* optional pob2.CharacterClass class_start_index */ 14:
                    message.classStartIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PassiveNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional pob2.NodeType node_type = 3; */
        if (message.nodeType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.nodeType);
        /* repeated string stats = 4; */
        for (let i = 0; i < message.stats.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.stats[i]);
        /* repeated string linked_ids = 5; */
        for (let i = 0; i < message.linkedIds.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.linkedIds[i]);
        /* optional pob2.Position position = 6; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 group = 7; */
        if (message.group !== undefined)
            writer.tag(7, WireType.Varint).int32(message.group);
        /* optional int32 orbit = 8; */
        if (message.orbit !== undefined)
            writer.tag(8, WireType.Varint).int32(message.orbit);
        /* optional int32 orbit_index = 9; */
        if (message.orbitIndex !== undefined)
            writer.tag(9, WireType.Varint).int32(message.orbitIndex);
        /* optional string ascendancy_name = 10; */
        if (message.ascendancyName !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.ascendancyName);
        /* optional bool is_ascendancy_start = 11; */
        if (message.isAscendancyStart !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isAscendancyStart);
        /* optional string icon = 12; */
        if (message.icon !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.icon);
        /* optional bool is_proxy = 13; */
        if (message.isProxy !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isProxy);
        /* optional pob2.CharacterClass class_start_index = 14; */
        if (message.classStartIndex !== undefined)
            writer.tag(14, WireType.Varint).int32(message.classStartIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.PassiveNode
 */
export const PassiveNode = new PassiveNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PassiveTree$Type extends MessageType<PassiveTree> {
    constructor() {
        super("pob2.PassiveTree", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PassiveNode },
            { no: 3, name: "groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => NodeGroup },
            { no: 10, name: "class_start_nodes", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 20, name: "constants", kind: "message", T: () => TreeConstants }
        ]);
    }
    create(value?: PartialMessage<PassiveTree>): PassiveTree {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.nodes = [];
        message.groups = [];
        message.classStartNodes = {};
        if (value !== undefined)
            reflectionMergePartial<PassiveTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PassiveTree): PassiveTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* repeated pob2.PassiveNode nodes */ 2:
                    message.nodes.push(PassiveNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated pob2.NodeGroup groups */ 3:
                    message.groups.push(NodeGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<int32, string> class_start_nodes */ 10:
                    this.binaryReadMap10(message.classStartNodes, reader, options);
                    break;
                case /* optional pob2.TreeConstants constants */ 20:
                    message.constants = TreeConstants.internalBinaryRead(reader, reader.uint32(), options, message.constants);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: PassiveTree["classStartNodes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PassiveTree["classStartNodes"] | undefined, val: PassiveTree["classStartNodes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.PassiveTree.class_start_nodes");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    internalBinaryWrite(message: PassiveTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* repeated pob2.PassiveNode nodes = 2; */
        for (let i = 0; i < message.nodes.length; i++)
            PassiveNode.internalBinaryWrite(message.nodes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated pob2.NodeGroup groups = 3; */
        for (let i = 0; i < message.groups.length; i++)
            NodeGroup.internalBinaryWrite(message.groups[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<int32, string> class_start_nodes = 10; */
        for (let k of globalThis.Object.keys(message.classStartNodes))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.classStartNodes[k as any]).join();
        /* optional pob2.TreeConstants constants = 20; */
        if (message.constants)
            TreeConstants.internalBinaryWrite(message.constants, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.PassiveTree
 */
export const PassiveTree = new PassiveTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeGroup$Type extends MessageType<NodeGroup> {
    constructor() {
        super("pob2.NodeGroup", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "position", kind: "message", T: () => Position },
            { no: 3, name: "node_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_proxy", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<NodeGroup>): NodeGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.nodeIds = [];
        if (value !== undefined)
            reflectionMergePartial<NodeGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeGroup): NodeGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional pob2.Position position */ 2:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* repeated string node_ids */ 3:
                    message.nodeIds.push(reader.string());
                    break;
                case /* optional bool is_proxy */ 4:
                    message.isProxy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional pob2.Position position = 2; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string node_ids = 3; */
        for (let i = 0; i < message.nodeIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.nodeIds[i]);
        /* optional bool is_proxy = 4; */
        if (message.isProxy !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isProxy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.NodeGroup
 */
export const NodeGroup = new NodeGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TreeConstants$Type extends MessageType<TreeConstants> {
    constructor() {
        super("pob2.TreeConstants", [
            { no: 1, name: "orbit_radii", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "skills_per_orbit", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TreeConstants>): TreeConstants {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.orbitRadii = [];
        message.skillsPerOrbit = [];
        if (value !== undefined)
            reflectionMergePartial<TreeConstants>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TreeConstants): TreeConstants {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 orbit_radii */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.orbitRadii.push(reader.int32());
                    else
                        message.orbitRadii.push(reader.int32());
                    break;
                case /* repeated int32 skills_per_orbit */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillsPerOrbit.push(reader.int32());
                    else
                        message.skillsPerOrbit.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TreeConstants, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 orbit_radii = 1; */
        if (message.orbitRadii.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.orbitRadii.length; i++)
                writer.int32(message.orbitRadii[i]);
            writer.join();
        }
        /* repeated int32 skills_per_orbit = 2; */
        if (message.skillsPerOrbit.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.skillsPerOrbit.length; i++)
                writer.int32(message.skillsPerOrbit[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.TreeConstants
 */
export const TreeConstants = new TreeConstants$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("pob2.Position", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item$Type extends MessageType<Item> {
    constructor() {
        super("pob2.Item", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type_line", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rarity", kind: "enum", opt: true, T: () => ["pob2.ItemRarity", ItemRarity] },
            { no: 6, name: "item_type", kind: "enum", opt: true, T: () => ["pob2.ItemType", ItemType] },
            { no: 10, name: "item_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "quality", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "corrupted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "mirrored", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "fractured", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "required_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "required_str", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "required_dex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "required_int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "sockets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Socket },
            { no: 31, name: "runes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "implicit_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "explicit_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "enchant_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "rune_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 44, name: "crafted_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 50, name: "weapon_data", kind: "message", T: () => WeaponData },
            { no: 51, name: "armour_data", kind: "message", T: () => ArmourData },
            { no: 52, name: "flask_data", kind: "message", T: () => FlaskData },
            { no: 53, name: "jewel_data", kind: "message", T: () => JewelData }
        ]);
    }
    create(value?: PartialMessage<Item>): Item {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.sockets = [];
        message.runes = [];
        message.implicitMods = [];
        message.explicitMods = [];
        message.enchantMods = [];
        message.runeMods = [];
        message.craftedMods = [];
        if (value !== undefined)
            reflectionMergePartial<Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item): Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string base_name */ 3:
                    message.baseName = reader.string();
                    break;
                case /* optional string type_line */ 4:
                    message.typeLine = reader.string();
                    break;
                case /* optional pob2.ItemRarity rarity */ 5:
                    message.rarity = reader.int32();
                    break;
                case /* optional pob2.ItemType item_type */ 6:
                    message.itemType = reader.int32();
                    break;
                case /* optional int32 item_level */ 10:
                    message.itemLevel = reader.int32();
                    break;
                case /* optional int32 quality */ 11:
                    message.quality = reader.int32();
                    break;
                case /* optional bool corrupted */ 12:
                    message.corrupted = reader.bool();
                    break;
                case /* optional bool mirrored */ 13:
                    message.mirrored = reader.bool();
                    break;
                case /* optional bool fractured */ 14:
                    message.fractured = reader.bool();
                    break;
                case /* optional int32 required_level */ 20:
                    message.requiredLevel = reader.int32();
                    break;
                case /* optional int32 required_str */ 21:
                    message.requiredStr = reader.int32();
                    break;
                case /* optional int32 required_dex */ 22:
                    message.requiredDex = reader.int32();
                    break;
                case /* optional int32 required_int */ 23:
                    message.requiredInt = reader.int32();
                    break;
                case /* repeated pob2.Socket sockets */ 30:
                    message.sockets.push(Socket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string runes */ 31:
                    message.runes.push(reader.string());
                    break;
                case /* repeated string implicit_mods */ 40:
                    message.implicitMods.push(reader.string());
                    break;
                case /* repeated string explicit_mods */ 41:
                    message.explicitMods.push(reader.string());
                    break;
                case /* repeated string enchant_mods */ 42:
                    message.enchantMods.push(reader.string());
                    break;
                case /* repeated string rune_mods */ 43:
                    message.runeMods.push(reader.string());
                    break;
                case /* repeated string crafted_mods */ 44:
                    message.craftedMods.push(reader.string());
                    break;
                case /* optional pob2.WeaponData weapon_data */ 50:
                    message.weaponData = WeaponData.internalBinaryRead(reader, reader.uint32(), options, message.weaponData);
                    break;
                case /* optional pob2.ArmourData armour_data */ 51:
                    message.armourData = ArmourData.internalBinaryRead(reader, reader.uint32(), options, message.armourData);
                    break;
                case /* optional pob2.FlaskData flask_data */ 52:
                    message.flaskData = FlaskData.internalBinaryRead(reader, reader.uint32(), options, message.flaskData);
                    break;
                case /* optional pob2.JewelData jewel_data */ 53:
                    message.jewelData = JewelData.internalBinaryRead(reader, reader.uint32(), options, message.jewelData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string base_name = 3; */
        if (message.baseName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.baseName);
        /* optional string type_line = 4; */
        if (message.typeLine !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.typeLine);
        /* optional pob2.ItemRarity rarity = 5; */
        if (message.rarity !== undefined)
            writer.tag(5, WireType.Varint).int32(message.rarity);
        /* optional pob2.ItemType item_type = 6; */
        if (message.itemType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.itemType);
        /* optional int32 item_level = 10; */
        if (message.itemLevel !== undefined)
            writer.tag(10, WireType.Varint).int32(message.itemLevel);
        /* optional int32 quality = 11; */
        if (message.quality !== undefined)
            writer.tag(11, WireType.Varint).int32(message.quality);
        /* optional bool corrupted = 12; */
        if (message.corrupted !== undefined)
            writer.tag(12, WireType.Varint).bool(message.corrupted);
        /* optional bool mirrored = 13; */
        if (message.mirrored !== undefined)
            writer.tag(13, WireType.Varint).bool(message.mirrored);
        /* optional bool fractured = 14; */
        if (message.fractured !== undefined)
            writer.tag(14, WireType.Varint).bool(message.fractured);
        /* optional int32 required_level = 20; */
        if (message.requiredLevel !== undefined)
            writer.tag(20, WireType.Varint).int32(message.requiredLevel);
        /* optional int32 required_str = 21; */
        if (message.requiredStr !== undefined)
            writer.tag(21, WireType.Varint).int32(message.requiredStr);
        /* optional int32 required_dex = 22; */
        if (message.requiredDex !== undefined)
            writer.tag(22, WireType.Varint).int32(message.requiredDex);
        /* optional int32 required_int = 23; */
        if (message.requiredInt !== undefined)
            writer.tag(23, WireType.Varint).int32(message.requiredInt);
        /* repeated pob2.Socket sockets = 30; */
        for (let i = 0; i < message.sockets.length; i++)
            Socket.internalBinaryWrite(message.sockets[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* repeated string runes = 31; */
        for (let i = 0; i < message.runes.length; i++)
            writer.tag(31, WireType.LengthDelimited).string(message.runes[i]);
        /* repeated string implicit_mods = 40; */
        for (let i = 0; i < message.implicitMods.length; i++)
            writer.tag(40, WireType.LengthDelimited).string(message.implicitMods[i]);
        /* repeated string explicit_mods = 41; */
        for (let i = 0; i < message.explicitMods.length; i++)
            writer.tag(41, WireType.LengthDelimited).string(message.explicitMods[i]);
        /* repeated string enchant_mods = 42; */
        for (let i = 0; i < message.enchantMods.length; i++)
            writer.tag(42, WireType.LengthDelimited).string(message.enchantMods[i]);
        /* repeated string rune_mods = 43; */
        for (let i = 0; i < message.runeMods.length; i++)
            writer.tag(43, WireType.LengthDelimited).string(message.runeMods[i]);
        /* repeated string crafted_mods = 44; */
        for (let i = 0; i < message.craftedMods.length; i++)
            writer.tag(44, WireType.LengthDelimited).string(message.craftedMods[i]);
        /* optional pob2.WeaponData weapon_data = 50; */
        if (message.weaponData)
            WeaponData.internalBinaryWrite(message.weaponData, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.ArmourData armour_data = 51; */
        if (message.armourData)
            ArmourData.internalBinaryWrite(message.armourData, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.FlaskData flask_data = 52; */
        if (message.flaskData)
            FlaskData.internalBinaryWrite(message.flaskData, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.JewelData jewel_data = 53; */
        if (message.jewelData)
            JewelData.internalBinaryWrite(message.jewelData, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Item
 */
export const Item = new Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Socket$Type extends MessageType<Socket> {
    constructor() {
        super("pob2.Socket", [
            { no: 1, name: "color", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "group", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Socket>): Socket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Socket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Socket): Socket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string color */ 1:
                    message.color = reader.string();
                    break;
                case /* optional int32 group */ 2:
                    message.group = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Socket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string color = 1; */
        if (message.color !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.color);
        /* optional int32 group = 2; */
        if (message.group !== undefined)
            writer.tag(2, WireType.Varint).int32(message.group);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Socket
 */
export const Socket = new Socket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponData$Type extends MessageType<WeaponData> {
    constructor() {
        super("pob2.WeaponData", [
            { no: 1, name: "physical_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "physical_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fire_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "fire_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cold_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cold_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "lightning_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "lightning_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "chaos_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "chaos_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "attack_speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "crit_chance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "range", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WeaponData>): WeaponData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WeaponData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponData): WeaponData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 physical_min */ 1:
                    message.physicalMin = reader.int32();
                    break;
                case /* optional int32 physical_max */ 2:
                    message.physicalMax = reader.int32();
                    break;
                case /* optional int32 fire_min */ 3:
                    message.fireMin = reader.int32();
                    break;
                case /* optional int32 fire_max */ 4:
                    message.fireMax = reader.int32();
                    break;
                case /* optional int32 cold_min */ 5:
                    message.coldMin = reader.int32();
                    break;
                case /* optional int32 cold_max */ 6:
                    message.coldMax = reader.int32();
                    break;
                case /* optional int32 lightning_min */ 7:
                    message.lightningMin = reader.int32();
                    break;
                case /* optional int32 lightning_max */ 8:
                    message.lightningMax = reader.int32();
                    break;
                case /* optional int32 chaos_min */ 9:
                    message.chaosMin = reader.int32();
                    break;
                case /* optional int32 chaos_max */ 10:
                    message.chaosMax = reader.int32();
                    break;
                case /* optional float attack_speed */ 11:
                    message.attackSpeed = reader.float();
                    break;
                case /* optional float crit_chance */ 12:
                    message.critChance = reader.float();
                    break;
                case /* optional int32 range */ 13:
                    message.range = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeaponData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 physical_min = 1; */
        if (message.physicalMin !== undefined)
            writer.tag(1, WireType.Varint).int32(message.physicalMin);
        /* optional int32 physical_max = 2; */
        if (message.physicalMax !== undefined)
            writer.tag(2, WireType.Varint).int32(message.physicalMax);
        /* optional int32 fire_min = 3; */
        if (message.fireMin !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fireMin);
        /* optional int32 fire_max = 4; */
        if (message.fireMax !== undefined)
            writer.tag(4, WireType.Varint).int32(message.fireMax);
        /* optional int32 cold_min = 5; */
        if (message.coldMin !== undefined)
            writer.tag(5, WireType.Varint).int32(message.coldMin);
        /* optional int32 cold_max = 6; */
        if (message.coldMax !== undefined)
            writer.tag(6, WireType.Varint).int32(message.coldMax);
        /* optional int32 lightning_min = 7; */
        if (message.lightningMin !== undefined)
            writer.tag(7, WireType.Varint).int32(message.lightningMin);
        /* optional int32 lightning_max = 8; */
        if (message.lightningMax !== undefined)
            writer.tag(8, WireType.Varint).int32(message.lightningMax);
        /* optional int32 chaos_min = 9; */
        if (message.chaosMin !== undefined)
            writer.tag(9, WireType.Varint).int32(message.chaosMin);
        /* optional int32 chaos_max = 10; */
        if (message.chaosMax !== undefined)
            writer.tag(10, WireType.Varint).int32(message.chaosMax);
        /* optional float attack_speed = 11; */
        if (message.attackSpeed !== undefined)
            writer.tag(11, WireType.Bit32).float(message.attackSpeed);
        /* optional float crit_chance = 12; */
        if (message.critChance !== undefined)
            writer.tag(12, WireType.Bit32).float(message.critChance);
        /* optional int32 range = 13; */
        if (message.range !== undefined)
            writer.tag(13, WireType.Varint).int32(message.range);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.WeaponData
 */
export const WeaponData = new WeaponData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArmourData$Type extends MessageType<ArmourData> {
    constructor() {
        super("pob2.ArmourData", [
            { no: 1, name: "armour", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "evasion", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "energy_shield", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "ward", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "block", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ArmourData>): ArmourData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ArmourData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArmourData): ArmourData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 armour */ 1:
                    message.armour = reader.int32();
                    break;
                case /* optional int32 evasion */ 2:
                    message.evasion = reader.int32();
                    break;
                case /* optional int32 energy_shield */ 3:
                    message.energyShield = reader.int32();
                    break;
                case /* optional int32 ward */ 4:
                    message.ward = reader.int32();
                    break;
                case /* optional int32 block */ 5:
                    message.block = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArmourData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 armour = 1; */
        if (message.armour !== undefined)
            writer.tag(1, WireType.Varint).int32(message.armour);
        /* optional int32 evasion = 2; */
        if (message.evasion !== undefined)
            writer.tag(2, WireType.Varint).int32(message.evasion);
        /* optional int32 energy_shield = 3; */
        if (message.energyShield !== undefined)
            writer.tag(3, WireType.Varint).int32(message.energyShield);
        /* optional int32 ward = 4; */
        if (message.ward !== undefined)
            writer.tag(4, WireType.Varint).int32(message.ward);
        /* optional int32 block = 5; */
        if (message.block !== undefined)
            writer.tag(5, WireType.Varint).int32(message.block);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.ArmourData
 */
export const ArmourData = new ArmourData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlaskData$Type extends MessageType<FlaskData> {
    constructor() {
        super("pob2.FlaskData", [
            { no: 1, name: "life_recovery", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "mana_recovery", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "charges_used", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "charges_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FlaskData>): FlaskData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FlaskData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlaskData): FlaskData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 life_recovery */ 1:
                    message.lifeRecovery = reader.int32();
                    break;
                case /* optional int32 mana_recovery */ 2:
                    message.manaRecovery = reader.int32();
                    break;
                case /* optional int32 duration */ 3:
                    message.duration = reader.int32();
                    break;
                case /* optional int32 charges_used */ 4:
                    message.chargesUsed = reader.int32();
                    break;
                case /* optional int32 charges_max */ 5:
                    message.chargesMax = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlaskData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 life_recovery = 1; */
        if (message.lifeRecovery !== undefined)
            writer.tag(1, WireType.Varint).int32(message.lifeRecovery);
        /* optional int32 mana_recovery = 2; */
        if (message.manaRecovery !== undefined)
            writer.tag(2, WireType.Varint).int32(message.manaRecovery);
        /* optional int32 duration = 3; */
        if (message.duration !== undefined)
            writer.tag(3, WireType.Varint).int32(message.duration);
        /* optional int32 charges_used = 4; */
        if (message.chargesUsed !== undefined)
            writer.tag(4, WireType.Varint).int32(message.chargesUsed);
        /* optional int32 charges_max = 5; */
        if (message.chargesMax !== undefined)
            writer.tag(5, WireType.Varint).int32(message.chargesMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.FlaskData
 */
export const FlaskData = new FlaskData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JewelData$Type extends MessageType<JewelData> {
    constructor() {
        super("pob2.JewelData", [
            { no: 1, name: "radius", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_cluster", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cluster_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JewelData>): JewelData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<JewelData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JewelData): JewelData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 radius */ 1:
                    message.radius = reader.int32();
                    break;
                case /* optional string limit */ 2:
                    message.limit = reader.string();
                    break;
                case /* optional bool is_cluster */ 3:
                    message.isCluster = reader.bool();
                    break;
                case /* optional int32 cluster_size */ 4:
                    message.clusterSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JewelData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 radius = 1; */
        if (message.radius !== undefined)
            writer.tag(1, WireType.Varint).int32(message.radius);
        /* optional string limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.limit);
        /* optional bool is_cluster = 3; */
        if (message.isCluster !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isCluster);
        /* optional int32 cluster_size = 4; */
        if (message.clusterSize !== undefined)
            writer.tag(4, WireType.Varint).int32(message.clusterSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.JewelData
 */
export const JewelData = new JewelData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkillGroup$Type extends MessageType<SkillGroup> {
    constructor() {
        super("pob2.SkillGroup", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_in_full_dps", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "slot", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "gems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GemInstance }
        ]);
    }
    create(value?: PartialMessage<SkillGroup>): SkillGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.gems = [];
        if (value !== undefined)
            reflectionMergePartial<SkillGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkillGroup): SkillGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* optional bool enabled */ 3:
                    message.enabled = reader.bool();
                    break;
                case /* optional bool include_in_full_dps */ 4:
                    message.includeInFullDps = reader.bool();
                    break;
                case /* optional string slot */ 5:
                    message.slot = reader.string();
                    break;
                case /* repeated pob2.GemInstance gems */ 10:
                    message.gems.push(GemInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkillGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* optional bool enabled = 3; */
        if (message.enabled !== undefined)
            writer.tag(3, WireType.Varint).bool(message.enabled);
        /* optional bool include_in_full_dps = 4; */
        if (message.includeInFullDps !== undefined)
            writer.tag(4, WireType.Varint).bool(message.includeInFullDps);
        /* optional string slot = 5; */
        if (message.slot !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.slot);
        /* repeated pob2.GemInstance gems = 10; */
        for (let i = 0; i < message.gems.length; i++)
            GemInstance.internalBinaryWrite(message.gems[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.SkillGroup
 */
export const SkillGroup = new SkillGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GemInstance$Type extends MessageType<GemInstance> {
    constructor() {
        super("pob2.GemInstance", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gem_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "quality", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "quality_type", kind: "enum", opt: true, T: () => ["pob2.GemQualityType", GemQualityType] }
        ]);
    }
    create(value?: PartialMessage<GemInstance>): GemInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GemInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GemInstance): GemInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string gem_id */ 2:
                    message.gemId = reader.string();
                    break;
                case /* optional int32 level */ 3:
                    message.level = reader.int32();
                    break;
                case /* optional int32 quality */ 4:
                    message.quality = reader.int32();
                    break;
                case /* optional bool enabled */ 5:
                    message.enabled = reader.bool();
                    break;
                case /* optional int32 count */ 6:
                    message.count = reader.int32();
                    break;
                case /* optional pob2.GemQualityType quality_type */ 10:
                    message.qualityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GemInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string gem_id = 2; */
        if (message.gemId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gemId);
        /* optional int32 level = 3; */
        if (message.level !== undefined)
            writer.tag(3, WireType.Varint).int32(message.level);
        /* optional int32 quality = 4; */
        if (message.quality !== undefined)
            writer.tag(4, WireType.Varint).int32(message.quality);
        /* optional bool enabled = 5; */
        if (message.enabled !== undefined)
            writer.tag(5, WireType.Varint).bool(message.enabled);
        /* optional int32 count = 6; */
        if (message.count !== undefined)
            writer.tag(6, WireType.Varint).int32(message.count);
        /* optional pob2.GemQualityType quality_type = 10; */
        if (message.qualityType !== undefined)
            writer.tag(10, WireType.Varint).int32(message.qualityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.GemInstance
 */
export const GemInstance = new GemInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gem$Type extends MessageType<Gem> {
    constructor() {
        super("pob2.Gem", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "gem_type", kind: "enum", opt: true, T: () => ["pob2.GemType", GemType] },
            { no: 4, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "levels", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GemLevel },
            { no: 20, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "base_mana_cost", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "base_cast_time", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "base_cooldown", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Gem>): Gem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.levels = [];
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<Gem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gem): Gem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional pob2.GemType gem_type */ 3:
                    message.gemType = reader.int32();
                    break;
                case /* optional string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated pob2.GemLevel levels */ 10:
                    message.levels.push(GemLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string tags */ 20:
                    message.tags.push(reader.string());
                    break;
                case /* optional int32 base_mana_cost */ 30:
                    message.baseManaCost = reader.int32();
                    break;
                case /* optional int32 base_cast_time */ 31:
                    message.baseCastTime = reader.int32();
                    break;
                case /* optional int32 base_cooldown */ 32:
                    message.baseCooldown = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional pob2.GemType gem_type = 3; */
        if (message.gemType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.gemType);
        /* optional string description = 4; */
        if (message.description !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated pob2.GemLevel levels = 10; */
        for (let i = 0; i < message.levels.length; i++)
            GemLevel.internalBinaryWrite(message.levels[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tags = 20; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(20, WireType.LengthDelimited).string(message.tags[i]);
        /* optional int32 base_mana_cost = 30; */
        if (message.baseManaCost !== undefined)
            writer.tag(30, WireType.Varint).int32(message.baseManaCost);
        /* optional int32 base_cast_time = 31; */
        if (message.baseCastTime !== undefined)
            writer.tag(31, WireType.Varint).int32(message.baseCastTime);
        /* optional int32 base_cooldown = 32; */
        if (message.baseCooldown !== undefined)
            writer.tag(32, WireType.Varint).int32(message.baseCooldown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Gem
 */
export const Gem = new Gem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GemLevel$Type extends MessageType<GemLevel> {
    constructor() {
        super("pob2.GemLevel", [
            { no: 1, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "required_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "mana_cost", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "damage_effectiveness", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "stats", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<GemLevel>): GemLevel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.stats = {};
        if (value !== undefined)
            reflectionMergePartial<GemLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GemLevel): GemLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* optional int32 required_level */ 2:
                    message.requiredLevel = reader.int32();
                    break;
                case /* optional int32 mana_cost */ 3:
                    message.manaCost = reader.int32();
                    break;
                case /* optional int32 damage_effectiveness */ 4:
                    message.damageEffectiveness = reader.int32();
                    break;
                case /* map<string, int32> stats */ 10:
                    this.binaryReadMap10(message.stats, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: GemLevel["stats"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GemLevel["stats"] | undefined, val: GemLevel["stats"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.GemLevel.stats");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: GemLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* optional int32 required_level = 2; */
        if (message.requiredLevel !== undefined)
            writer.tag(2, WireType.Varint).int32(message.requiredLevel);
        /* optional int32 mana_cost = 3; */
        if (message.manaCost !== undefined)
            writer.tag(3, WireType.Varint).int32(message.manaCost);
        /* optional int32 damage_effectiveness = 4; */
        if (message.damageEffectiveness !== undefined)
            writer.tag(4, WireType.Varint).int32(message.damageEffectiveness);
        /* map<string, int32> stats = 10; */
        for (let k of globalThis.Object.keys(message.stats))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.stats[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.GemLevel
 */
export const GemLevel = new GemLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LevelingPath$Type extends MessageType<LevelingPath> {
    constructor() {
        super("pob2.LevelingPath", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "build_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "class_id", kind: "enum", opt: true, T: () => ["pob2.CharacterClass", CharacterClass] },
            { no: 5, name: "checkpoints", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Checkpoint },
            { no: 6, name: "steps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LevelingStep },
            { no: 7, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<LevelingPath>): LevelingPath {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.checkpoints = [];
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<LevelingPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LevelingPath): LevelingPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string build_id */ 2:
                    message.buildId = reader.string();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional pob2.CharacterClass class_id */ 4:
                    message.classId = reader.int32();
                    break;
                case /* repeated pob2.Checkpoint checkpoints */ 5:
                    message.checkpoints.push(Checkpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated pob2.LevelingStep steps */ 6:
                    message.steps.push(LevelingStep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string notes */ 7:
                    message.notes = reader.string();
                    break;
                case /* optional google.protobuf.Timestamp created_at */ 8:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* optional google.protobuf.Timestamp updated_at */ 9:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LevelingPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string build_id = 2; */
        if (message.buildId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.buildId);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional pob2.CharacterClass class_id = 4; */
        if (message.classId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.classId);
        /* repeated pob2.Checkpoint checkpoints = 5; */
        for (let i = 0; i < message.checkpoints.length; i++)
            Checkpoint.internalBinaryWrite(message.checkpoints[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated pob2.LevelingStep steps = 6; */
        for (let i = 0; i < message.steps.length; i++)
            LevelingStep.internalBinaryWrite(message.steps[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string notes = 7; */
        if (message.notes !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.notes);
        /* optional google.protobuf.Timestamp created_at = 8; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp updated_at = 9; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.LevelingPath
 */
export const LevelingPath = new LevelingPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Checkpoint$Type extends MessageType<Checkpoint> {
    constructor() {
        super("pob2.Checkpoint", [
            { no: 1, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "allocated_passives", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "equipment", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Item } },
            { no: 4, name: "gems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SkillGroup },
            { no: 5, name: "stats", kind: "message", T: () => StatSnapshot },
            { no: 6, name: "notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Checkpoint>): Checkpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.allocatedPassives = [];
        message.equipment = {};
        message.gems = [];
        if (value !== undefined)
            reflectionMergePartial<Checkpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Checkpoint): Checkpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* repeated string allocated_passives */ 2:
                    message.allocatedPassives.push(reader.string());
                    break;
                case /* map<string, pob2.Item> equipment */ 3:
                    this.binaryReadMap3(message.equipment, reader, options);
                    break;
                case /* repeated pob2.SkillGroup gems */ 4:
                    message.gems.push(SkillGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional pob2.StatSnapshot stats */ 5:
                    message.stats = StatSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* optional string notes */ 6:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Checkpoint["equipment"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Checkpoint["equipment"] | undefined, val: Checkpoint["equipment"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Item.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.Checkpoint.equipment");
            }
        }
        map[key ?? ""] = val ?? Item.create();
    }
    internalBinaryWrite(message: Checkpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* repeated string allocated_passives = 2; */
        for (let i = 0; i < message.allocatedPassives.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.allocatedPassives[i]);
        /* map<string, pob2.Item> equipment = 3; */
        for (let k of globalThis.Object.keys(message.equipment)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Item.internalBinaryWrite(message.equipment[k], writer, options);
            writer.join().join();
        }
        /* repeated pob2.SkillGroup gems = 4; */
        for (let i = 0; i < message.gems.length; i++)
            SkillGroup.internalBinaryWrite(message.gems[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.StatSnapshot stats = 5; */
        if (message.stats)
            StatSnapshot.internalBinaryWrite(message.stats, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string notes = 6; */
        if (message.notes !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.Checkpoint
 */
export const Checkpoint = new Checkpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LevelingStep$Type extends MessageType<LevelingStep> {
    constructor() {
        super("pob2.LevelingStep", [
            { no: 1, name: "order", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "trigger", kind: "message", T: () => StepTrigger },
            { no: 3, name: "action", kind: "message", T: () => StepAction },
            { no: 4, name: "stat_delta", kind: "message", T: () => StatDelta },
            { no: 5, name: "rationale", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LevelingStep>): LevelingStep {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.order = 0;
        if (value !== undefined)
            reflectionMergePartial<LevelingStep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LevelingStep): LevelingStep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 order */ 1:
                    message.order = reader.int32();
                    break;
                case /* optional pob2.StepTrigger trigger */ 2:
                    message.trigger = StepTrigger.internalBinaryRead(reader, reader.uint32(), options, message.trigger);
                    break;
                case /* optional pob2.StepAction action */ 3:
                    message.action = StepAction.internalBinaryRead(reader, reader.uint32(), options, message.action);
                    break;
                case /* optional pob2.StatDelta stat_delta */ 4:
                    message.statDelta = StatDelta.internalBinaryRead(reader, reader.uint32(), options, message.statDelta);
                    break;
                case /* optional string rationale */ 5:
                    message.rationale = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LevelingStep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 order = 1; */
        if (message.order !== 0)
            writer.tag(1, WireType.Varint).int32(message.order);
        /* optional pob2.StepTrigger trigger = 2; */
        if (message.trigger)
            StepTrigger.internalBinaryWrite(message.trigger, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.StepAction action = 3; */
        if (message.action)
            StepAction.internalBinaryWrite(message.action, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional pob2.StatDelta stat_delta = 4; */
        if (message.statDelta)
            StatDelta.internalBinaryWrite(message.statDelta, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string rationale = 5; */
        if (message.rationale !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.rationale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.LevelingStep
 */
export const LevelingStep = new LevelingStep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepTrigger$Type extends MessageType<StepTrigger> {
    constructor() {
        super("pob2.StepTrigger", [
            { no: 1, name: "type", kind: "enum", T: () => ["pob2.StepTriggerType", StepTriggerType] },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StepTrigger>): StepTrigger {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<StepTrigger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepTrigger): StepTrigger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pob2.StepTriggerType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepTrigger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pob2.StepTriggerType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.StepTrigger
 */
export const StepTrigger = new StepTrigger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepAction$Type extends MessageType<StepAction> {
    constructor() {
        super("pob2.StepAction", [
            { no: 1, name: "type", kind: "enum", T: () => ["pob2.StepActionType", StepActionType] },
            { no: 2, name: "target_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slot", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "details", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StepAction>): StepAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<StepAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepAction): StepAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pob2.StepActionType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string target_id */ 2:
                    message.targetId = reader.string();
                    break;
                case /* optional string slot */ 3:
                    message.slot = reader.string();
                    break;
                case /* optional string details */ 4:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pob2.StepActionType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string target_id = 2; */
        if (message.targetId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.targetId);
        /* optional string slot = 3; */
        if (message.slot !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.slot);
        /* optional string details = 4; */
        if (message.details !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.StepAction
 */
export const StepAction = new StepAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatDelta$Type extends MessageType<StatDelta> {
    constructor() {
        super("pob2.StatDelta", [
            { no: 1, name: "dps_percent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "ehp_percent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "dps_absolute", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "ehp_absolute", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "resistances", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 6, name: "other_stats", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<StatDelta>): StatDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resistances = {};
        message.otherStats = {};
        if (value !== undefined)
            reflectionMergePartial<StatDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatDelta): StatDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float dps_percent */ 1:
                    message.dpsPercent = reader.float();
                    break;
                case /* optional float ehp_percent */ 2:
                    message.ehpPercent = reader.float();
                    break;
                case /* optional float dps_absolute */ 3:
                    message.dpsAbsolute = reader.float();
                    break;
                case /* optional float ehp_absolute */ 4:
                    message.ehpAbsolute = reader.float();
                    break;
                case /* map<string, float> resistances */ 5:
                    this.binaryReadMap5(message.resistances, reader, options);
                    break;
                case /* map<string, float> other_stats */ 6:
                    this.binaryReadMap6(message.otherStats, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: StatDelta["resistances"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatDelta["resistances"] | undefined, val: StatDelta["resistances"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.StatDelta.resistances");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap6(map: StatDelta["otherStats"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatDelta["otherStats"] | undefined, val: StatDelta["otherStats"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.StatDelta.other_stats");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: StatDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float dps_percent = 1; */
        if (message.dpsPercent !== undefined)
            writer.tag(1, WireType.Bit32).float(message.dpsPercent);
        /* optional float ehp_percent = 2; */
        if (message.ehpPercent !== undefined)
            writer.tag(2, WireType.Bit32).float(message.ehpPercent);
        /* optional float dps_absolute = 3; */
        if (message.dpsAbsolute !== undefined)
            writer.tag(3, WireType.Bit32).float(message.dpsAbsolute);
        /* optional float ehp_absolute = 4; */
        if (message.ehpAbsolute !== undefined)
            writer.tag(4, WireType.Bit32).float(message.ehpAbsolute);
        /* map<string, float> resistances = 5; */
        for (let k of globalThis.Object.keys(message.resistances))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.resistances[k]).join();
        /* map<string, float> other_stats = 6; */
        for (let k of globalThis.Object.keys(message.otherStats))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.otherStats[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.StatDelta
 */
export const StatDelta = new StatDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatSnapshot$Type extends MessageType<StatSnapshot> {
    constructor() {
        super("pob2.StatSnapshot", [
            { no: 1, name: "dps", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "ehp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "life", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "mana", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "energy_shield", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "fire_res", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "cold_res", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "lightning_res", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "chaos_res", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "attack_speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "cast_speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "crit_chance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "crit_multi", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "other", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<StatSnapshot>): StatSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.other = {};
        if (value !== undefined)
            reflectionMergePartial<StatSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatSnapshot): StatSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float dps */ 1:
                    message.dps = reader.float();
                    break;
                case /* optional float ehp */ 2:
                    message.ehp = reader.float();
                    break;
                case /* optional float life */ 3:
                    message.life = reader.float();
                    break;
                case /* optional float mana */ 4:
                    message.mana = reader.float();
                    break;
                case /* optional float energy_shield */ 5:
                    message.energyShield = reader.float();
                    break;
                case /* optional int32 fire_res */ 6:
                    message.fireRes = reader.int32();
                    break;
                case /* optional int32 cold_res */ 7:
                    message.coldRes = reader.int32();
                    break;
                case /* optional int32 lightning_res */ 8:
                    message.lightningRes = reader.int32();
                    break;
                case /* optional int32 chaos_res */ 9:
                    message.chaosRes = reader.int32();
                    break;
                case /* optional float attack_speed */ 10:
                    message.attackSpeed = reader.float();
                    break;
                case /* optional float cast_speed */ 11:
                    message.castSpeed = reader.float();
                    break;
                case /* optional float crit_chance */ 12:
                    message.critChance = reader.float();
                    break;
                case /* optional float crit_multi */ 13:
                    message.critMulti = reader.float();
                    break;
                case /* map<string, float> other */ 14:
                    this.binaryReadMap14(message.other, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap14(map: StatSnapshot["other"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StatSnapshot["other"] | undefined, val: StatSnapshot["other"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for pob2.StatSnapshot.other");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: StatSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float dps = 1; */
        if (message.dps !== undefined)
            writer.tag(1, WireType.Bit32).float(message.dps);
        /* optional float ehp = 2; */
        if (message.ehp !== undefined)
            writer.tag(2, WireType.Bit32).float(message.ehp);
        /* optional float life = 3; */
        if (message.life !== undefined)
            writer.tag(3, WireType.Bit32).float(message.life);
        /* optional float mana = 4; */
        if (message.mana !== undefined)
            writer.tag(4, WireType.Bit32).float(message.mana);
        /* optional float energy_shield = 5; */
        if (message.energyShield !== undefined)
            writer.tag(5, WireType.Bit32).float(message.energyShield);
        /* optional int32 fire_res = 6; */
        if (message.fireRes !== undefined)
            writer.tag(6, WireType.Varint).int32(message.fireRes);
        /* optional int32 cold_res = 7; */
        if (message.coldRes !== undefined)
            writer.tag(7, WireType.Varint).int32(message.coldRes);
        /* optional int32 lightning_res = 8; */
        if (message.lightningRes !== undefined)
            writer.tag(8, WireType.Varint).int32(message.lightningRes);
        /* optional int32 chaos_res = 9; */
        if (message.chaosRes !== undefined)
            writer.tag(9, WireType.Varint).int32(message.chaosRes);
        /* optional float attack_speed = 10; */
        if (message.attackSpeed !== undefined)
            writer.tag(10, WireType.Bit32).float(message.attackSpeed);
        /* optional float cast_speed = 11; */
        if (message.castSpeed !== undefined)
            writer.tag(11, WireType.Bit32).float(message.castSpeed);
        /* optional float crit_chance = 12; */
        if (message.critChance !== undefined)
            writer.tag(12, WireType.Bit32).float(message.critChance);
        /* optional float crit_multi = 13; */
        if (message.critMulti !== undefined)
            writer.tag(13, WireType.Bit32).float(message.critMulti);
        /* map<string, float> other = 14; */
        for (let k of globalThis.Object.keys(message.other))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.other[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pob2.StatSnapshot
 */
export const StatSnapshot = new StatSnapshot$Type();
